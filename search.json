[
  
    {
      "title": "The Album Exchange Story",
      "url": "/general/2025/06/06/the-album-exchange-story.html",
      "date": "June 06, 2025",
      "content": "During the height of Covid, a bunch of brave people gathered around a table and said, “Enough is enough!” and decided to take matters into their own hands. So they made a Discord channel to pair up random people and recommend music, and this was called Album Exchange.\n\nThat no longer exists, and Spotify’s recommendation algorithm—pardon my language—sucks ass, which is why I have decided to be brave and build a website to get album recommendations.\n\n\n  \n  Album Exchange\n\n\nThe Core Idea\n\nThe concept is intentionally simple:\n\n\n  I feature a weekly album pick on the homepage\n  You can submit one album recommendation per week\n  Your submission automatically becomes a playlist on my Spotify account\n  Everyone can browse the gallery of all submitted albums\n  The site shows what I’m currently listening to (when I am)\n\n\nTechnical Challenges\n\nThe Spotify API\n\nI have never used Spotify’s API before, so I had to learn to do a few things like:\n\n\n  Fetch album details for display\n  Create playlists automatically from submissions\n  Show my current listening status\n  Handle rate limits gracefully\n\n\nThe rate limit challenge was enjoyable. Spotify is generous with its limits, but you can hit walls quickly when fetching album art and details for every submission. I ended up implementing a caching strategy with multiple fallbacks:\n\n// cache album details for 24h\nconst albumDetailsCache = new Map();\nconst ALBUM_CACHE_DURATION = 24 * 60 * 60 * 1000;\n\n// retry logic with exponential backoff\nasync function fetchWithRetry(fetchFn, maxRetries = MAX_RETRIES) {\n\tlet retryDelay = INITIAL_RETRY_DELAY;\n\n\tfor (let attempt = 0; attempt &lt;= maxRetries; attempt++) {\n\t\ttry {\n\t\t\treturn await fetchFn();\n\t\t} catch (error) {\n\t\t\tif (error.status === 429) {\n\t\t\t\tconst waitTime = error.retryAfter\n\t\t\t\t\t? error.retryAfter * 1000\n\t\t\t\t\t: retryDelay;\n\t\t\t\tawait new Promise((resolve) =&gt; setTimeout(resolve, waitTime));\n\t\t\t\tretryDelay *= 2;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nPreventing Spam\n\nI hate when websites make me sign up. I just want people to be able to submit recommendations, but I also didn’t want someone to flood the site with a 47-album playlist of “souljaboytellem.com.” So, I needed a rate-limiting system without asking the users to sign up.\n\nI went with a combination of IP address and browser fingerprinting:\n\nfunction generateSubmissionId(ip, fingerprint) {\n\treturn crypto\n\t\t.createHash(\"sha256\")\n\t\t.update(ip + (fingerprint || \"\") + (process.env.IP_SALT || \"\"))\n\t\t.digest(\"hex\");\n}\n\n\nThis creates a unique but anonymized identifier for each user. The salt means I can’t reverse-engineer the original data, and the one-way hash means the system is privacy-friendly while preventing abuse.\n\nThe rate limit resets every Monday at midnight UTC, which gives the site a nice weekly rhythm.\n\nThe Playlist Creation Magic\n\nThis part is my favorite. When someone submits an album, I don’t just store it in a database—I create a Spotify playlist on my account with all the tracks from that album.\n\nexport async function createAlbumPlaylist(albumId, nickname, albumName) {\n\tconst api = await getSpotifyApi();\n\n\t// get my user profile\n\tconst me = await api.currentUser.profile();\n\n\t// create playlist with format \"nickname-album title\"\n\tconst playlistName = `${nickname}-${albumName}`.substring(0, 100);\n\tconst playlist = await api.playlists.createPlaylist(me.id, {\n\t\tname: playlistName,\n\t\tdescription: `album recommendation from ${nickname} via bhav.fun`,\n\t\tpublic: false,\n\t});\n\n\t// get all tracks from the album\n\tconst albumTracks = await api.albums.tracks(albumId);\n\n\t// add them to the playlist\n\tif (albumTracks.items.length &gt; 0) {\n\t\tconst trackUris = albumTracks.items.map((track) =&gt; track.uri);\n\t\tawait api.playlists.addItemsToPlaylist(playlist.id, trackUris);\n\t}\n\n\treturn playlist;\n}\n\n\nWhich means every recommendation becomes an immediately playable playlist. I realize I have let the internet control my Spotify; there is a non-zero chance I wake up to my Spotify having a playlist called “Penis-Punisher.” But please don’t do that. I beg.\n\nArchitecture: Next.js + Firebase + Prayers\n\nThe stack is pretty straightforward:\n\n\n  Next.js for the frontend and API routes\n  Firebase Firestore for storing submissions\n  Spotify Web API for everything music-related\n  Vercel for hosting\n\n\nI organized it around clear separation of concerns:\n\n├── app/                  # Next.js pages and API routes\n├── components/           # React components (all the cozy UI bits)\n├── lib/                  # Services and utilities\n│   ├── spotify-service.js     # All Spotify API interactions\n│   ├── firebase-service.js    # Database operations\n│   ├── fingerprint-service.js # Rate limiting\n│   └── url-utils.js           # Input validation and cleaning\n\n\nThe API design is RESTful but pragmatic. For example, the submission endpoint does the following:\n\n\n  Validate the rate limit\n  Sanitizes inputs\n  Validates Spotify URLs\n  Fetches album details\n  Create the playlist\n  Stores everything in the database\n\n\nIt’s not the most “pure” API design, but it works well for this use case where each submission is a complex multi-step operation.\n\nSome Interesting Problems I Solved\n\nDynamic Album Cards\n\nI wanted album cards that could dynamically load their artwork and details from just a Spotify URL. This led to an interesting caching strategy where I cache both in-browser (localStorage) and server-side, with intelligent fallbacks when things go wrong.\n\nResponsive Image Handling\n\nAlbum artwork comes in various sizes from Spotify, and I needed it to look good across devices. Next.js’s Image component helped a lot, but I still had to handle edge cases like missing artwork:\n\n&lt;Image\n\tsrc={albumImage || \"/images/album-placeholder.jpg\"}\n\talt={`Album cover: ${albumName} by ${artistName}`}\n\twidth={300}\n\theight={300}\n\tquality={85}\n\tplaceholder=\"blur\"\n\tblurDataURL=\"data:image/svg+xml,...\"\n\tonError={onImageError}\n/&gt;\n\n\nThe “Now Playing” Feature\n\nI quickly realized this was slightly more nuanced than expected because Spotify’s “currently playing” endpoint doesn’t always have data. So I fall back to “recently played” and show that instead, with appropriate labeling. It makes the site feel more alive and personal.\n\nThe Unexpected Joy of Building Something Small\n\n\n  \n  The Zen of Python\n\n\nOne of the most rewarding aspects of this project was its scope. I built and shipped the MVP in two days, and it immediately felt proper and complete. There’s something deeply satisfying about creating a tool that solves exactly one problem well.\n\nIt also forced me to make decisions quickly. Should I build user accounts? Should I add social features? Should I integrate with other music services? For now, the answer to all of these is “no,” and that simplicity is part of what makes the site charming.\n\nSome Technical Details You Might Care About\n\nSecurity: All user inputs are sanitized, URLs are validated to ensure they’re actually Spotify links, and the rate-limiting system is designed to be privacy-friendly.\n\nPerformance: Album details are cached aggressively, images are optimized with Next.js’s Image component, and the Spotify API calls include retry logic and error handling.\n\nAccessibility: I tried to follow best practices, such as semantic HTML, proper focus management, alt text for images, and keyboard navigation support.\n\nSEO: The site has proper meta tags, a sitemap, and structured data to help with discovery.\n\nWhat’s Next\n\nAs sad as it is, my hyper fixation on this site has worn off, but I’m sure I will revisit this, and when I do, I’d like to make:\n\n\n  Better error handling for edge cases\n  More granular caching strategies\n  Maybe a Grand Spotify playlist that’s automatically updated with all submissions\n\n\nBut I’m pretty happy with it as it is. Sometimes, the best software is the kind that does exactly what it says it will do without trying to be everything to everyone.\n\nTry It Out\n\nYou can check out Album Exchange yourself. Please submit an album you love, browse what others have recommended, or look around the source code on GitHub.\n\nAnd if you build something similar or have ideas for improvements, I’d love to hear about it. The best part of sharing projects like this is the conversations they start.\n",
      "tags": ["album-exchange","music","spotify"]
    },
  
    {
      "title": "A Brand New Old Website",
      "url": "/general/2025/05/17/a-brand-new-old-website.html",
      "date": "May 17, 2025",
      "content": "Welcome to yet another iteration of my website.\n\n\n\nI built the first version of my portfolio, even before I owned this domain, shortly after my first web programming class during my undergrad, using plain HTML, CSS, and JS.\n\n\n \n portfolio v1\n\n\nAfter about a year, I built the second version—a single-page ThreeJS application with a cool 3D render (GLTF) of a PC setup. This is, by far, the flashiest project I’ve ever worked on. I learned so much when I was working on it, like the fact that I do not enjoy working with 3D files.\n\n\n \n portfolio v2\n\n\nLike clockwork, I got bored after a year and built a new one overnight that was much simpler using ReactJS. This time, it even had a blog section—but I never published anything, so did it really have a blog section?\n\nIt was a really shitty website, probably the worst one of the three so far. But the homepage was a clean bento-grid layout, so I let it hang around for a while, thinking I’d fix all its flaws during Christmas.\n\n\n \n portfolio v3\n\n\nI tried about four or five variations of this new site, even building them using different frameworks. My use case was pretty simple: I needed a blog site to yap, with a place for people to leave comments if they wish to do so and to post the photos I’ve taken.\n\nAt last, I have settled on an extremely simple yet elegant solution: Jekyll + GitHub pages. This site is almost entirely markdown-based, and dare I say, i fw it heavy. I really like how clean and simple it looks. I intend to use this space to write about projects I’m working on and also to talk about anything and everything I find interesting.\n\nHere’s the link to my RSS feed\n\nSee you around!\n\n\n\n\n\n\n\nPS: thanks to everyone who continues to make cool shit, and thanks to the people who’ve inspired me to build this site: den, neal, nolen, tru, jan, manuel, ezri, melody, and many, many more.\n\nPPS: cute cat that follows the cursor: github.com/adryd325/oneko.js\n",
      "tags": ["portfolio"]
    }
  
]